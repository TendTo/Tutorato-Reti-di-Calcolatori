var _a;function assert(t,e,r=Error){if(!t)throw new r(e||"Assertion failed")}export function querySelector(t,e){const r=document.querySelector(t);if(!r)throw new Error(`Element not found: ${t}`);if(!(r instanceof e))throw new TypeError(`Element is not a ${e.constructor.name}`);return r}export class BitArray{static getNewWordArray(t,e){if(8===t)return new Uint8Array(e);if(16===t)return new Uint16Array(e);if(32===t)return new Uint32Array(e);if(t===Uint8Array||t===Uint16Array||t===Uint32Array)return new t(e);if(t instanceof Uint8Array)return new Uint8Array(e);if(t instanceof Uint16Array)return new Uint16Array(e);if(t instanceof Uint32Array)return new Uint32Array(e);throw new TypeError("Invalid word size. Must be 8, 16 or 32")}constructor(t,e=32){if("number"==typeof t)this._length=t,this._buffer=new ArrayBuffer(Math.ceil(this._length/e)*e/8),this._wordArray=BitArray.getNewWordArray(e,this._buffer);else if(t instanceof BitArray){this._length=t.length,this._buffer=new ArrayBuffer(t._buffer.byteLength),this._wordArray=BitArray.getNewWordArray(t._wordArray,this._buffer);for(let e=0;e<t._wordArray.length;e++)this._wordArray[e]=t._wordArray[e]}else{if(!(t instanceof Uint8Array||t instanceof Uint16Array||t instanceof Uint32Array))throw new TypeError("Invalid type. Must be number, BitArray, Uint32Array or Uint8Array");this._length=8*t.byteLength,this._buffer=new ArrayBuffer(t.byteLength),this._wordArray=BitArray.getNewWordArray(t,this._buffer);for(let e=0;e<t.length;e++)this._wordArray[e]=t[e]}}get length(){return this._length}get buffer(){return this._buffer.slice(0)}get wordArray(){return this._wordArray.slice(0)}get wordSize(){if(this._wordArray instanceof Uint8Array)return 8;if(this._wordArray instanceof Uint16Array)return 16;if(this._wordArray instanceof Uint32Array)return 32;throw new TypeError("Invalid type. Must be Typed Array")}get moduleMask(){return this.wordSize-1}get maxValue(){return Math.pow(2,this.wordSize)-1}get bitsPerElement(){return 8*this._wordArray.BYTES_PER_ELEMENT}_getBitMask(t){return 1<<this.bitsPerElement-1-(t&this.moduleMask)}_getWordIdx(t){return Math.floor(t/this.wordSize)}set(t,e){assert(t>=0&&t<this.length,"Index must be between 0 and "+(this.length-1),RangeError);const r=this._getWordIdx(t);e?this._wordArray[r]|=this._getBitMask(t):this._wordArray[r]&=~this._getBitMask(t)}get(t){assert(t>=0&&t<this.length,"Index must be between 0 and "+(this.length-1),RangeError);const e=this._getWordIdx(t);return 0!=(this._wordArray[e]&this._getBitMask(t))}toggle(t){assert(t>=0&&t<this.length,"Index must be between 0 and "+(this.length-1),RangeError);const e=this._getWordIdx(t);this._wordArray[e]^=this._getBitMask(t)}reset(){this._buffer=new ArrayBuffer(this._wordArray.byteLength),this._wordArray=BitArray.getNewWordArray(this._wordArray,this._buffer)}copy(){const t=new BitArray(this.length,this.wordSize);for(let e=0;e<this._wordArray.length;e++)t._wordArray[e]=this._wordArray[e];return t}equals(t){if(this.length!==t.length)return!1;for(let e=0;e<this._wordArray.length;e++)if(this._wordArray[e]!==t._wordArray[e])return!1;return!0}toArray(){const t=[];for(let e=0;e<this.length;e++)t.push(this.get(e));return t}toJSON(){return JSON.stringify(this.toArray())}toBinaryString(){return this.toArray().map((t=>t?"1":"0")).join("")}toUint8Array(){return new Uint8Array(this._buffer.slice(0))}toUint16Array(){return new Uint16Array(this._buffer.slice(0))}toUint32Array(){return new Uint32Array(this._buffer.slice(0))}setAll(t){const e=(1<<this.wordSize)-1;for(let r=0;r<this._wordArray.length;r++)this._wordArray[r]=t?e:0}setToTrueAfter(t){this.setToAfter(t,!0)}setToFalseAfter(t){this.setToAfter(t,!1)}setToAfter(t,e){if(t<0||t>=this.length)return;const r=(1<<this.wordSize)-1,s=this._getWordIdx(t),i=(1<<this.bitsPerElement-(t&this.moduleMask))-1;e?this._wordArray[s]|=i:this._wordArray[s]&=~i;for(let t=s+1;t<this._wordArray.length;t++)this._wordArray[t]=e?r:0}not(){for(let t=0;t<this._wordArray.length;t++)this._wordArray[t]=~this._wordArray[t];return this}or(t){if(this.length!==t.length)throw TypeError("Arguments must be of the same length.");for(let e=0;e<this._wordArray.length;e++)this._wordArray[e]|=t._wordArray[e];return this}and(t){if(this.length!==t.length)throw TypeError("Arguments must be of the same length.");for(let e=0;e<this._wordArray.length;e++)this._wordArray[e]&=t._wordArray[e];return this}xor(t){if(this.length!==t.length)throw TypeError("Arguments must be of the same length.");for(let e=0;e<this._wordArray.length;e++)this._wordArray[e]^=t._wordArray[e];return this}toString(){return this.toBinaryString()}}export class IP{get maxMask(){return this._bits.length}get bytes(){return this._bits}get mask(){return this._mask}get netmask(){const t=new BitArray(this._bits);return t.setAll(!0),t.setToFalseAfter(this._mask),t.wordArray}isValidMask(t){return"number"==typeof t&&t>=1&&t<=this.maxMask}constructor(t,e){if(t instanceof Uint8Array||t instanceof Uint16Array)this._bits=new BitArray(t);else{if(!(t instanceof BitArray))throw new TypeError("Invalid type. Must be string, array or Uint8Array");this._bits=t.copy()}if(!this.isValidMask(e))throw new TypeError(`Mask must be a number between 0 and ${this.maxMask}`);this._mask=e}set mask(t){assert(this.isValidMask(t),`Mask must be a number between 0 and ${this.maxMask}`,RangeError),this._mask=t}get numIPs(){return 1<<this.maxMask-this._mask}getChildren(){return[this.left,this.right]}get _left(){assert(this._mask<this.maxMask,`Cannot get children if mask is already ${this.maxMask}`,RangeError);const t=this._bits.copy();return t.set(this._mask,!1),t}get _right(){assert(this._mask<this.maxMask,`Cannot get children if mask is already ${this.maxMask}`,RangeError);const t=this._bits.copy();return t.set(this._mask,!0),t}}export class IPv4 extends IP{static isIPv4(t){return _a.ipRegex.test(t)}constructor(t,e){t instanceof Uint8Array?assert(4===t.length,"Uint8Array must have 4 elements",RangeError):t instanceof BitArray?assert(32===t.length,"BitArray must have 32 elements",RangeError):Array.isArray(t)?t=_a._parseArray(t):"string"==typeof t&&(t=_a._parseString(t)),super(t,e)}static _parseString(t){const e=t.match(_a.ipRegex);if(!e||5!==e.length)throw new TypeError(`Invalid IPv4 address: '${t}'`);return new Uint8Array(e.slice(1).map((t=>parseInt(t))))}static _parseArray(t){return assert(4===t.length,"Array must have 4 elements",RangeError),assert(t.every((t=>t>=0&&t<=255)),"Elements of the array must be between 0 and 255",RangeError),new Uint8Array(t)}get network(){const t=this._bits.copy();return t.setToFalseAfter(this._mask),new _a(t,this._mask)}get broadcast(){const t=this._bits.copy();return t.setToTrueAfter(this._mask),new _a(t,this._mask)}get numHosts(){return this._mask===this.maxMask?1:this._mask===this.maxMask-1?2:(1<<this.maxMask-this._mask)-2}get left(){return new _a(this._left,this._mask+1)}get right(){return new _a(this._right,this._mask+1)}get first(){if(this._mask===this.maxMask)return this;if(this._mask===this.maxMask-1){const t=this._bits.copy();return t.set(this.maxMask-1,!1),new _a(t,this._mask)}const t=this._bits.copy();return t.setToFalseAfter(this._mask),t.set(this.maxMask-1,!0),new _a(t,this._mask)}get last(){if(this._mask===this.maxMask)return this;if(this._mask===this.maxMask-1){const t=this._bits.copy();return t.set(this.maxMask-1,!0),new _a(t,this._mask)}const t=this._bits.copy();return t.setToTrueAfter(this._mask),t.set(this.maxMask-1,!1),new _a(t,this._mask)}getChildren(){return[this.left,this.right]}toString(){return`${this._bits.toUint8Array().join(".")}/${this._mask}`}ipToString(){return`${this._bits.toUint8Array().join(".")}`}}_a=IPv4,IPv4.ipv4PartRegex="(0*(?:25[0-5]|(?:2[0-4]|1\\d|[1-9]|)\\d))",IPv4.ipRegex=new RegExp(`^${_a.ipv4PartRegex}\\.${_a.ipv4PartRegex}\\.${_a.ipv4PartRegex}\\.${_a.ipv4PartRegex}$`);export class IPv6 extends IP{static isIPv6(t){return IPv6.ipv6Regex.test(t)}constructor(t,e){t instanceof Uint16Array?assert(8===t.length,"Uint16Array must have 8 elements",RangeError):t instanceof BitArray?assert(128===t.length,"BitArray must have 128 elements",RangeError):Array.isArray(t)?t=IPv6._parseArray(t):"string"==typeof t&&(t=IPv6._parseString(t)),super(t,e)}static _parseString(t){assert(IPv6.ipv6Regex.test(t),`Invalid IPv6 address: ${t}`,TypeError);const e=new Uint16Array(8),r=t.split("::");if(2===r.length){let t=r[0].split(":"),s=r[1].split(":");1===t.length&&""===t[0]&&(t=[]),1===s.length&&""===s[0]&&(s=[]);const i=8-(t.length+s.length);for(let r=0;r<t.length;r++)e[r]=parseInt(t[r],16);for(let t=0;t<s.length;t++)e[i+t]=parseInt(s[t],16)}else{if(1!==r.length)throw new TypeError(`Invalid IPv6 address: ${t}`);{const r=t.split(":");assert(8===r.length,"Invalid IPv6 address",TypeError);for(let s=0;s<r.length;s++){const i=parseInt(r[s],16);assert(!isNaN(i)&&0<=i&&i<=65535,`Invalid IPv6 address: ${t}`,TypeError),e[s]=i}}}return e}static _parseArray(t){return assert(8===t.length,"Array must have 4 elements",RangeError),assert(t.every((t=>t>=0&&t<=65535)),"Elements of the array must be between 0 and 0xffff",RangeError),new Uint16Array(t)}get network(){const t=this._bits.copy();return t.setToFalseAfter(this._mask),new IPv6(t,this._mask)}get broadcast(){throw new Error("No broadcast address for IPv6")}get numHosts(){return this.numIPs}get left(){return new IPv6(this._left,this._mask+1)}get right(){return new IPv6(this._right,this._mask+1)}get first(){if(this._mask===this.maxMask)return this;const t=this._bits.copy();return t.setToFalseAfter(this._mask),new IPv6(t,this._mask)}get last(){if(this._mask===this.maxMask)return this;const t=this._bits.copy();return t.setToTrueAfter(this._mask),new IPv6(t,this._mask)}getChildren(){return[this.left,this.right]}toString(){return`${this.ipToString()}/${this._mask}`}ipToString(){const t=[],e=this._bits.toUint16Array();for(let r=0;r<e.length;r++)t.push(e[r].toString(16));return`${t.join(":")}`}}IPv6.ipv6Regex=/^(([0-9a-fA-F]{1,4}:){7,7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:)|fe80:(:[0-9a-fA-F]{0,4}){0,4}%[0-9a-zA-Z]{1,}|::(ffff(:0{1,4}){0,1}:){0,1}((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])|([0-9a-fA-F]{1,4}:){1,4}:((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9]))$/;export class IpNode{constructor(t,e,r,s,i,n=!1,a=!1){this._value=t,this._x=e,this._y=r,this._width=s,this._height=i,this._selected=n,this._hidden=a}get value(){return this._value}get selected(){return this._selected}get hidden(){return this._hidden}isClicked(t,e){return t>=this._x&&t<=this._x+this._width&&e>=this._y&&e<=this._y+this._height}setSelected(t,e){this._selected=t,t&&(this._hidden=!1),e&&this.draw(e)}setHidden(t,e){this._hidden=t,t&&(this._selected=!1),e&&this.draw(e)}draw(t){if(this._hidden)return void t.clearRect(this._x,this._y,this._width,this._height);t.drawRect(this._x,this._y,this._width,this._height,this._selected?"lightblue":"white","black");const e=Math.ceil(Math.min(16,this._width/10));t.drawText(this._value.toString(),this._x+this._width/2,this._y+this._height/2,{font:`${e}px sans-serif`})}getChildren(){const[t,e]=this._value.getChildren();return[new IpNode(t,this._x,this._y+this._height,this._width/2,this._height),new IpNode(e,this._x+this._width/2,this._y+this._height,this._width/2,this._height)]}}export class CanvasDrawer{constructor(t="#canvas"){this._ipNodes=[],this._canvas=querySelector(t,HTMLCanvasElement);const e=this._canvas.parentNode.getBoundingClientRect();this._canvas.width=e.width,this._canvas.height=e.height;const r=this._canvas.getContext("2d",{alpha:!1});if(!r)throw new Error("Could not get 2d context");this._ctx=r,this._addListeners()}_addListeners(){this._canvas.addEventListener("click",this._onMouseClick.bind(this)),this._canvas.addEventListener("contextmenu",this._onMouseRightClick.bind(this))}_onMouseClick(t){var e;for(const r of this._ipNodes)if(r.isClicked(t.offsetX,t.offsetY)&&!r.hidden){null===(e=this.onMouseClick)||void 0===e||e.call(this,r.value);break}}_onMouseRightClick(t){var e;t.preventDefault();for(let r=this._ipNodes.length-1;r>=0;r--){const s=this._ipNodes[r];if(s.isClicked(t.offsetX,t.offsetY)&&!s.hidden){const t=!s.selected;t&&(null===(e=this.onMouseClick)||void 0===e||e.call(this,s.value)),s.setSelected(t,this);const i=[2*(r+1)-1,2*(r+1)];for(;i.length>0;){const e=i.shift();void 0===e||e>this._ipNodes.length||(this._ipNodes[e].setHidden(t,this),i.push(2*(e+1)-1,2*(e+1)))}}}}get canvas(){return this._canvas}get context(){return this._ctx}clear(){this._ctx.clearRect(0,0,this._canvas.width,this._canvas.height)}clearRect(t,e,r,s){this._ctx.clearRect(t,e,r,s)}drawRect(t,e,r,s,i,n){i&&(this._ctx.fillStyle=i,this._ctx.fillRect(t,e,r,s)),n&&(this._ctx.strokeStyle=n,this._ctx.strokeRect(t,e,r,s))}drawText(t,e,r,{align:s,baseline:i,fill:n,font:a}={}){this._ctx.font=null!=a?a:"16px sans-serif",this._ctx.fillStyle=null!=n?n:"black",this._ctx.textAlign=null!=s?s:"center",this._ctx.textBaseline=null!=i?i:"middle",this._ctx.fillText(t,e,r)}drawLine(t,e,r,s,i){const n=new Path2D;n.moveTo(t,e),n.lineTo(r,s),this._ctx.strokeStyle=null!=i?i:"black",this._ctx.stroke(n)}drawIpTree(t,e){if(e<1)return;const r=Math.floor(this._canvas.height/e),s=new IpNode(t,0,0,this._canvas.width,r),i=[s];this._ipNodes=[s],s.draw(this);const n=(1<<e)-1;for(;this._ipNodes.length<n;){const t=i.shift();if(!t)break;try{const[e,r]=t.getChildren();i.push(e,r),this._ipNodes.push(e,r),e.draw(this),r.draw(this)}catch(t){break}}}}export class InputManager{constructor(t="#ipRoot",e="#maskRoot",r="#treeHeight",s="#toNetwork"){this._ipRoot=querySelector(t,HTMLInputElement),this._maskRoot=querySelector(e,HTMLInputElement),this._treeHeight=querySelector(r,HTMLInputElement),this._toNetwork=querySelector(s,HTMLInputElement),this._ip=new IPv4(this._ipRoot.value,this._maskRoot.valueAsNumber),this._treeHeightValue=this._treeHeight.valueAsNumber,this._toNetworkValue=this._toNetwork.checked,this._addListeners()}_addListeners(){this._treeHeight.addEventListener("input",this._onTreeHeightClick.bind(this)),this._maskRoot.addEventListener("input",this._maskRootInput.bind(this)),this._ipRoot.addEventListener("input",this._onIpRootInput.bind(this)),this._toNetwork.addEventListener("change",this._onToNetworkChange.bind(this))}_onIpRootInput(t){var e;if(!(t.target instanceof HTMLInputElement))return;if(!t.target.validity.valid)return;let r=this._ip.mask;IPv4.isIPv4(t.target.value)?(this._maskRoot.max="32",this._maskRoot.valueAsNumber>32&&(this._maskRoot.value="32",r=32),this._ip=new IPv4(t.target.value,r)):(this._maskRoot.max="128",this._ip=new IPv6(t.target.value,r)),null===(e=this.onUpdateIp)||void 0===e||e.call(this,this._ip,this._treeHeightValue,this._toNetworkValue)}_maskRootInput(t){var e;t.target instanceof HTMLInputElement&&t.target.validity.valid&&(this._ip.mask=t.target.valueAsNumber,null===(e=this.onUpdateIp)||void 0===e||e.call(this,this._ip,this._treeHeightValue,this._toNetworkValue))}_onTreeHeightClick(t){var e;t.target instanceof HTMLInputElement&&t.target.validity.valid&&(this._treeHeightValue=t.target.valueAsNumber,null===(e=this.onUpdateIp)||void 0===e||e.call(this,this._ip,this._treeHeightValue,this._toNetworkValue))}_onToNetworkChange(t){var e;t.target instanceof HTMLInputElement&&(this._toNetworkValue=t.target.checked,null===(e=this.onUpdateIp)||void 0===e||e.call(this,this._ip,this._treeHeightValue,this._toNetworkValue))}get ip(){return this._ip}get treeHeight(){return this._treeHeight.valueAsNumber}get toNetworkValue(){return this._toNetworkValue}}export class InfoManager{constructor(t="#showIp",e="#showNetmask",r="#showNetwork",s="#showBroadcast",i="#showMinIp",n="#showMaxIp",a="#showNumIp",h="#showNumHost"){this._showIp=querySelector(t,HTMLSpanElement),this._showNetmask=querySelector(e,HTMLSpanElement),this._showNetwork=querySelector(r,HTMLSpanElement),this._showBroadcast=querySelector(s,HTMLSpanElement),this._showMinIp=querySelector(i,HTMLSpanElement),this._showMaxIp=querySelector(n,HTMLSpanElement),this._showNumIp=querySelector(a,HTMLSpanElement),this._showNumHost=querySelector(h,HTMLSpanElement),this.update()}update(t){if(!t)return this._showIp.textContent="",this._showNetmask.textContent="",this._showNetwork.textContent="",this._showBroadcast.textContent="",this._showMinIp.textContent="",this._showMaxIp.textContent="",this._showNumIp.textContent="",void(this._showNumHost.textContent="");if(this._showIp.textContent=t.toString(),t instanceof IPv4)this._showNetmask.textContent=t.netmask.join("."),this._showNetwork.textContent=t.network.ipToString(),this._showBroadcast.textContent=t.broadcast.ipToString();else{const e=[];t.netmask.forEach((t=>e.push(t.toString(16)))),this._showNetmask.textContent=e.join(":")}this._showMinIp.textContent=t.first.ipToString(),this._showMaxIp.textContent=t.last.ipToString(),t.maxMask-t.mask<31?(this._showNumIp.textContent=t.numIPs.toLocaleString(),this._showNumHost.textContent=t.numHosts.toLocaleString()):(this._showNumIp.textContent="2^"+(t.maxMask-t.mask),this._showNumHost.textContent=`2^${t.maxMask-t.mask} ${t instanceof IPv4?" - 2":""}`)}}window.onload=()=>{console.log("%c There is not much to see here. Just a canvas and a bunch of inputs.\nIf you are just curious about how its made, you can find everything at https://github.com/TendTo/Tutorato-Reti-di-Calcolatori.","color:lime;background:black;"),console.log("%c If you think you can improve the repulsive visual presentation, you are more than welcome to do so.","font-weight: bold; font-size: 32px;color: red; text-shadow: 2px 2px 0 rgb(217,31,38) , 4px 4px 0 rgb(226,91,14) , 6px 6px 0 rgb(245,221,8) , 8px 8px 0 rgb(5,148,68) , 10px 10px 0 rgb(2,135,206) , 12px 12px 0 rgb(4,77,145) , 14px 14px 0 rgb(42,21,113)");const t=new InputManager,e=new CanvasDrawer,r=new InfoManager,s=(t,s,i)=>{r.update(),e.clear(),e.drawIpTree(i?t.network:t,s)};t.onUpdateIp=s,e.onMouseClick=r.update.bind(r),s(t.ip,t.treeHeight,t.toNetworkValue)};